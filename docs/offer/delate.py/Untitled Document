class Solution:
    def __init__(self):
        self.memo = {'':1, 'D':1, 'I':1} # 记忆化
    def numPermsDISequence(self, S):
        """
        :type S: str
        :rtype: int
        """
        # 分治 + 动态规划
        # time complexity: O(n^2)
        n = len(S)
        if S in self.memo:
            return self.memo[S]
        CONST = 10**9 + 7
        ans = 0
        if S[0] == "D": # 最大数出现在最左端
            ans += self.numPermsDISequence(S[1:])
        if S[-1] == "I": # 最大数出现在最右端
            ans += self.numPermsDISequence(S[:-1])
        comb = 1 # 组合数
        for i in range(n-1):
            comb = comb*(n-i)//(i+1)
            if S[i:i+2] == "ID": # 最大数出现在中间
                temp1, temp2 = S[:i], S[i+2:]
                ans += self.numPermsDISequence(temp1)*self.numPermsDISequence(temp2)*comb
                ans %= CONST
        self.memo[S] = ans
        return ans

作者：smoon1989
链接：https://leetcode-cn.com/problems/valid-permutations-for-di-sequence/solution/fen-zhi-dong-tai-gui-hua-python3-by-smoon1989/
来源：力扣（LeetCode）
著作权归作者所有。商业转载请联系作者获得授权，非商业转载请注明出处。
